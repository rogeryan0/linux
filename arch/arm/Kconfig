#
# For a description of the syntax of this configuration file,
# see Documentation/kbuild/kconfig-language.txt.
#

mainmenu "Linux Kernel Configuration"

config ARM
	bool
	default y
	select RTC_LIB
	select SYS_SUPPORTS_APM_EMULATION
	help
	  The ARM series is a line of low-power-consumption RISC chip designs
	  licensed by ARM Ltd and targeted at embedded applications and
	  handhelds such as the Compaq IPAQ.  ARM-based PCs are no longer
	  manufactured, but legacy ARM-based PC hardware remains popular in
	  Europe.  There is an ARM Linux project with a web page at
	  <http://www.arm.linux.org.uk/>.

config SYS_SUPPORTS_APM_EMULATION
	bool

config GENERIC_GPIO
	bool
	default n

config GENERIC_TIME
	bool
	default n

config GENERIC_CLOCKEVENTS
	bool
	default n

config MMU
	bool
	default y

config NO_IOPORT
	bool
	default n

config EISA
	bool
	---help---
	  The Extended Industry Standard Architecture (EISA) bus was
	  developed as an open alternative to the IBM MicroChannel bus.

	  The EISA bus provided some of the features of the IBM MicroChannel
	  bus while maintaining backward compatibility with cards made for
	  the older ISA bus.  The EISA bus saw limited use between 1988 and
	  1995 when it was made obsolete by the PCI bus.

	  Say Y here if you are building a kernel for an EISA-based machine.

	  Otherwise, say N.

config SBUS
	bool

config MCA
	bool
	help
	  MicroChannel Architecture is found in some IBM PS/2 machines and
	  laptops.  It is a bus system similar to PCI or ISA. See
	  <file:Documentation/mca.txt> (and especially the web page given
	  there) before attempting to build an MCA bus kernel.

config GENERIC_HARDIRQS
	bool
	default y

config STACKTRACE_SUPPORT
	bool
	default y

config LOCKDEP_SUPPORT
	bool
	default y

config TRACE_IRQFLAGS_SUPPORT
	bool
	default y

config HARDIRQS_SW_RESEND
	bool
	default y

config GENERIC_IRQ_PROBE
	bool
	default y

config RWSEM_GENERIC_SPINLOCK
	bool
	default y

config RWSEM_XCHGADD_ALGORITHM
	bool

config ARCH_HAS_ILOG2_U32
	bool
	default n

config ARCH_HAS_ILOG2_U64
	bool
	default n

config GENERIC_HWEIGHT
	bool
	default y

config GENERIC_CALIBRATE_DELAY
	bool
	default y

config ARCH_MAY_HAVE_PC_FDC
	bool

config ZONE_DMA
	bool
	default y

config GENERIC_ISA_DMA
	bool

config FIQ
	bool

config ARCH_MTD_XIP
	bool

config VECTORS_BASE
	hex
	default 0xffff0000 if MMU || CPU_HIGH_VECTOR
	default DRAM_BASE if REMAP_VECTORS_TO_RAM
	default 0x00000000
	help
	  The base address of exception vectors.

source "init/Kconfig"

menu "System Type"

choice
	prompt "ARM system type"
	default ARCH_FEROCEON_KW

config ARCH_FEROCEON_ORION
        bool "Feroceon-Orion based"
	select ARCH_FEROCEON
        select PCI
	select GENERIC_TIME
        select GENERIC_CLOCKEVENTS

config ARCH_FEROCEON_KW
        bool "Feroceon-KW based"
	select ARCH_FEROCEON
	select PCI
	select GENERIC_TIME
        select GENERIC_CLOCKEVENTS

config ARCH_FEROCEON_MV78XX0
        bool "Feroceon-MV78XX0 based"
	select ARCH_FEROCEON
	select PCI
	select GENERIC_TIME
        select GENERIC_CLOCKEVENTS

endchoice

menu "BUFFALO Features"

config BUFFALO_PLATFORM
	bool "BUFFALO_PLATFORM"
	---help---
	  Hardware/Software is BUFFALO platfrom

config USE_REFERENCE_PCB
	bool "USE_REFERENCE PCB"
	---help---
	  Hardware is Reference platfrom

config BUFFALO_ERRCNT
	bool "BUFFALO_ERRCNT"
        ---help---
          disk I/O error counter and auto MD degrading.

config BUFFALO_SCAN
	bool "BUFFALO_SCAN"
        ----help---
	  MD redundancy array scan and repair sector error.

config BUFFALO_DEGRADEKEEP
	bool "BUFFALO_DEGRADEKEEP"
        ----help---
	  keeping MD degrade state.

config DEBUG_RAID
	bool "DEBUG_RAID"
	----help---
	  I/O error emulation code for debugging redundancy array.
          (disk_brk_req_r, disk_brk_req_w, err_r_prob)

config BUFFALO_SOFT_BOARDID
	bool "USE SOFT_BOARDID"
	depends on BUFFALO_PLATFORM

config USE_RS5C372
	bool "USE RTC chip RS5C372"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO  arch/arm/mach-mv88fxx81/Board/rtc/mvDS1339Reg.h.c

config BUFFALO_USE_MICON
	bool "USE MICON control"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO  buffalo/drivers

config BUFFALO_USE_INTERRUPT_DRIVER
	bool "USE interrupt driver"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO buffalo/drivers

config BUFFALO_USE_GPIO_DRIVER
	bool "USE gpio driver"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO buffalo/drivers
	  Only use for miconless models.

config BUFFALO_SUPPORT_BOARD_INFO
	bool "support board info from kernel"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO  buffalo/drivers

config BUFFALO_SUPPORT_WHITE_SPACE_ISERIAL
	bool "Enable make_guid white space skip routine"
	depends on BUFFALO_PLATFORM
	default n
	---help---
	  BUFFALO drivers/usb/storage/scsiglue.c
	  If this option would enable, make_guid routine will change.
	  White space of USB iSerial is ignored in the time to generate GUID.

config BUFFALO_USE_UPS
	bool "USE UPS control"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO  buffalo/drivers

config BUFFALO_ENABLE_TESTCODE
	bool "enable debug codes"
	depends on BUFFALO_PLATFORM
	---help---
	  BUFFALO buffalo/drivers

endmenu


#if ARCH_FEROCEON_ORION || ARCH_FEROCEON_MV78XX0
#source "arch/arm/plat-feroceon/Kconfig"
#endif

if ARCH_FEROCEON_KW
source "arch/arm/plat-feroceon-kw/Kconfig"
endif

# Definitions to make life easier
config ARCH_ACORN
	bool

config PLAT_IOP
	bool

config ARCH_FEROCEON
	bool

source arch/arm/mm/Kconfig

config IWMMXT
	bool "Enable iWMMXt support"
	depends on CPU_XSCALE || CPU_XSC3
	default y if PXA27x
	help
	  Enable support for iWMMXt context switching at run time if
	  running on a CPU that supports it.

#  bool 'Use XScale PMU as timer source' CONFIG_XSCALE_PMU_TIMER
config XSCALE_PMU
	bool
	depends on CPU_XSCALE && !XSCALE_PMU_TIMER
	default y

if !MMU
source "arch/arm/Kconfig-nommu"
endif

endmenu

source "arch/arm/common/Kconfig"

config FORCE_MAX_ZONEORDER
	int
	depends on SA1111
	default "9"

menu "Bus support"

config ARM_AMBA
	bool

config ISA
	bool
	help
	  Find out whether you have ISA slots on your motherboard.  ISA is the
	  name of a bus system, i.e. the way the CPU talks to the other stuff
	  inside your box.  Other bus systems are PCI, EISA, MicroChannel
	  (MCA) or VESA.  ISA is an older system, now being displaced by PCI;
	  newer boards don't support it.  If you have ISA, say Y, otherwise N.

# Select ISA DMA controller support
config ISA_DMA
	bool
	select ISA_DMA_API

# Select ISA DMA interface
config ISA_DMA_API
	bool

config PCI
	bool "PCI support" if ARCH_INTEGRATOR_AP || ARCH_VERSATILE_PB || ARCH_IXP4XX || ARCH_KS8695 || ARCH_FEROCEON
	help
	  Find out whether you have a PCI motherboard. PCI is the name of a
	  bus system, i.e. the way the CPU talks to the other stuff inside
	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
	  VESA. If you have PCI, say Y, otherwise N.

	  The PCI-HOWTO, available from
	  <http://www.tldp.org/docs.html#howto>, contains valuable
	  information about which PCI hardware does work under Linux and which
	  doesn't.

# Select the host bridge type
config PCI_HOST_VIA82C505
	bool
	depends on PCI && ARCH_SHARK
	default y

source "drivers/pci/Kconfig"

source "drivers/pcmcia/Kconfig"

endmenu

menu "Kernel Features"

source "kernel/time/Kconfig"

config SMP
	bool "Symmetric Multi-Processing (EXPERIMENTAL)"
	depends on EXPERIMENTAL && REALVIEW_MPCORE
	help
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, like most personal computers, say N. If
	  you have a system with more than one CPU, say Y.

	  If you say N here, the kernel will run on single and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all, single
	  processor machines. On a single processor machine, the kernel will
	  run faster if you say N here.

	  See also the <file:Documentation/smp.txt>,
	  <file:Documentation/i386/IO-APIC.txt>,
	  <file:Documentation/nmi_watchdog.txt> and the SMP-HOWTO available at
	  <http://www.linuxdoc.org/docs.html#howto>.

	  If you don't know what to do here, say N.

config NR_CPUS
	int "Maximum number of CPUs (2-32)"
	range 2 32
	depends on SMP
	default "4"

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs (EXPERIMENTAL)"
	depends on SMP && HOTPLUG && EXPERIMENTAL
	help
	  Say Y here to experiment with turning CPUs off and on.  CPUs
	  can be controlled through /sys/devices/system/cpu.

config LOCAL_TIMERS
	bool "Use local timer interrupts"
	depends on SMP && REALVIEW_MPCORE
	default y
	help
	  Enable support for local timers on SMP platforms, rather then the
	  legacy IPI broadcast method.  Local timers allows the system
	  accounting to be spread across the timer interval, preventing a
	  "thundering herd" at every timer tick.

config PREEMPT
	bool "Preemptible Kernel (EXPERIMENTAL)"
	depends on EXPERIMENTAL
	help
	  This option reduces the latency of the kernel when reacting to
	  real-time or interactive events by allowing a low priority process to
	  be preempted even if it is in kernel mode executing a system call.
	  This allows applications to run more reliably even when the system is
	  under load.

	  Say Y here if you are building a kernel for a desktop, embedded
	  or real-time system.  Say N if you are unsure.

config NO_IDLE_HZ
	bool "Dynamic tick timer"
	depends on !GENERIC_CLOCKEVENTS
	help
	  Select this option if you want to disable continuous timer ticks
	  and have them programmed to occur as required. This option saves
	  power as the system can remain in idle state for longer.

	  By default dynamic tick is disabled during the boot, and can be
	  manually enabled with:

	    echo 1 > /sys/devices/system/timer/timer0/dyn_tick

	  Alternatively, if you want dynamic tick automatically enabled
	  during boot, pass "dyntick=enable" via the kernel command string.

	  Please note that dynamic tick may affect the accuracy of
	  timekeeping on some platforms depending on the implementation.
	  Currently at least OMAP, PXA2xx and SA11x0 platforms are known
	  to have accurate timekeeping with dynamic tick.

config HZ
	int
	default 128 if ARCH_L7200
	default 200 if ARCH_EBSA110 || ARCH_S3C2410
	default OMAP_32K_TIMER_HZ if ARCH_OMAP && OMAP_32K_TIMER
	default 100

config AEABI
	bool "Use the ARM EABI to compile the kernel"
	help
	  This option allows for the kernel to be compiled using the latest
	  ARM ABI (aka EABI).  This is only useful if you are using a user
	  space environment that is also compiled with EABI.

	  Since there are major incompatibilities between the legacy ABI and
	  EABI, especially with regard to structure member alignment, this
	  option also changes the kernel syscall calling convention to
	  disambiguate both ABIs and allow for backward compatibility support
	  (selected with CONFIG_OABI_COMPAT).

	  To use this you need GCC version 4.0.0 or later.

config OABI_COMPAT
	bool "Allow old ABI binaries to run with this kernel (EXPERIMENTAL)"
	depends on AEABI && EXPERIMENTAL
	default y
	help
	  This option preserves the old syscall interface along with the
	  new (ARM EABI) one. It also provides a compatibility layer to
	  intercept syscalls that have structure arguments which layout
	  in memory differs between the legacy ABI and the new ARM EABI
	  (only for non "thumb" binaries). This option adds a tiny
	  overhead to all syscalls and produces a slightly larger kernel.
	  If you know you'll be using only pure EABI user space then you
	  can say N here. If this option is not selected and you attempt
	  to execute a legacy ABI binary then the result will be
	  UNPREDICTABLE (in fact it can be predicted that it won't work
	  at all). If in doubt say Y.

config REORDER
        bool "Function reordering"
        default n
        help
          This option enables the toolchain to reorder functions for a more
          optimal TLB/Icache usage. If you have pretty much any version of binutils,
          this can increase your kernel build time by roughly one minute.

config ARCH_DISCONTIGMEM_ENABLE
	bool
	default (ARCH_LH7A40X && !LH7A40X_CONTIGMEM)
	help
	  Say Y to support efficient handling of discontiguous physical memory,
	  for architectures which are either NUMA (Non-Uniform Memory Access)
	  or have huge holes in the physical address space for other reasons.
	  See <file:Documentation/vm/numa> for more.

config NODES_SHIFT
	int
	default "4" if ARCH_LH7A40X
	default "2"
	depends on NEED_MULTIPLE_NODES

source "mm/Kconfig"

config LEDS
	bool "Timer and CPU usage LEDs"
	depends on ARCH_CDB89712 || ARCH_CO285 || ARCH_EBSA110 || \
		   ARCH_EBSA285 || ARCH_IMX || ARCH_INTEGRATOR || \
		   ARCH_LUBBOCK || MACH_MAINSTONE || ARCH_NETWINDER || \
		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
		   ARCH_AT91 || MACH_TRIZEPS4 || ARCH_DAVINCI || \
		   ARCH_KS8695 || ARCH_FEROCEON
	help
	  If you say Y here, the LEDs on your machine will be used
	  to provide useful information about your current system status.

	  If you are compiling a kernel for a NetWinder or EBSA-285, you will
	  be able to select which LEDs are active using the options below. If
	  you are compiling a kernel for the EBSA-110 or the LART however, the
	  red LED will simply flash regularly to indicate that the system is
	  still functional. It is safe to say Y here if you have a CATS
	  system, but the driver will do nothing.

config LEDS_TIMER
	bool "Timer LED" if (!ARCH_CDB89712 && !ARCH_OMAP) || \
			    MACH_OMAP_H2 || MACH_OMAP_PERSEUS2
	depends on LEDS
	depends on !GENERIC_CLOCKEVENTS
	default y if ARCH_EBSA110
	help
	  If you say Y here, one of the system LEDs (the green one on the
	  NetWinder, the amber one on the EBSA285, or the red one on the LART)
	  will flash regularly to indicate that the system is still
	  operational. This is mainly useful to kernel hackers who are
	  debugging unstable kernels.

	  The LART uses the same LED for both Timer LED and CPU usage LED
	  functions. You may choose to use both, but the Timer LED function
	  will overrule the CPU usage LED.

config LEDS_CPU
	bool "CPU usage LED" if (!ARCH_CDB89712 && !ARCH_EBSA110 && \
			!ARCH_OMAP) || MACH_OMAP_H2 || MACH_OMAP_PERSEUS2
	depends on LEDS
	help
	  If you say Y here, the red LED will be used to give a good real
	  time indication of CPU usage, by lighting whenever the idle task
	  is not currently executing.

	  The LART uses the same LED for both Timer LED and CPU usage LED
	  functions. You may choose to use both, but the Timer LED function
	  will overrule the CPU usage LED.

config ALIGNMENT_TRAP
	bool
	depends on CPU_CP15_MMU
	default y if !ARCH_EBSA110
	help
	  ARM processors cannot fetch/store information which is not
	  naturally aligned on the bus, i.e., a 4 byte fetch must start at an
	  address divisible by 4. On 32-bit ARM processors, these non-aligned
	  fetch/store instructions will be emulated in software if you say
	  here, which has a severe performance impact. This is necessary for
	  correct operation of some network protocols. With an IP-only
	  configuration it is safe to say N, otherwise say Y.

endmenu

menu "Boot options"

# Compressed boot loader in ROM.  Yes, we really want to ask about
# TEXT and BSS so we preserve their values in the config files.
config ZBOOT_ROM_TEXT
	hex "Compressed ROM boot loader base address"
	default "0"
	help
	  The physical address at which the ROM-able zImage is to be
	  placed in the target.  Platforms which normally make use of
	  ROM-able zImage formats normally set this to a suitable
	  value in their defconfig file.

	  If ZBOOT_ROM is not enabled, this has no effect.

config ZBOOT_ROM_BSS
	hex "Compressed ROM boot loader BSS address"
	default "0"
	help
	  The base address of an area of read/write memory in the target
	  for the ROM-able zImage which must be available while the
	  decompressor is running. It must be large enough to hold the
	  entire decompressed kernel plus an additional 128 KiB.
	  Platforms which normally make use of ROM-able zImage formats
	  normally set this to a suitable value in their defconfig file.

	  If ZBOOT_ROM is not enabled, this has no effect.

config ZBOOT_ROM
	bool "Compressed boot loader in ROM/flash"
	depends on ZBOOT_ROM_TEXT != ZBOOT_ROM_BSS
	help
	  Say Y here if you intend to execute your compressed kernel image
	  (zImage) directly from ROM or flash.  If unsure, say N.

config CMDLINE
	string "Default kernel command string"
	default ""
	help
	  On some architectures (EBSA110 and CATS), there is currently no way
	  for the boot loader to pass arguments to the kernel. For these
	  architectures, you should supply some command-line options at build
	  time by entering them here. As a minimum, you should specify the
	  memory size and the root device (e.g., mem=64M root=/dev/nfs).

config XIP_KERNEL
	bool "Kernel Execute-In-Place from ROM"
	depends on !ZBOOT_ROM
	help
	  Execute-In-Place allows the kernel to run from non-volatile storage
	  directly addressable by the CPU, such as NOR flash. This saves RAM
	  space since the text section of the kernel is not loaded from flash
	  to RAM.  Read-write sections, such as the data section and stack,
	  are still copied to RAM.  The XIP kernel is not compressed since
	  it has to run directly from flash, so it will take more space to
	  store it.  The flash address used to link the kernel object files,
	  and for storing it, is configuration dependent. Therefore, if you
	  say Y here, you must know the proper physical address where to
	  store the kernel image depending on your own flash memory usage.

	  Also note that the make target becomes "make xipImage" rather than
	  "make zImage" or "make Image".  The final kernel binary to put in
	  ROM memory will be arch/arm/boot/xipImage.

	  If unsure, say N.

config XIP_PHYS_ADDR
	hex "XIP Kernel Physical Location"
	depends on XIP_KERNEL
	default "0x00080000"
	help
	  This is the physical address in your flash memory the kernel will
	  be linked for and stored to.  This address is dependent on your
	  own flash usage.

config KEXEC
	bool "Kexec system call (EXPERIMENTAL)"
	depends on EXPERIMENTAL
	help
	  kexec is a system call that implements the ability to shutdown your
	  current kernel, and to start another kernel.  It is like a reboot
	  but it is indepedent of the system firmware.   And like a reboot
	  you can start any kernel with it, not just Linux.

	  It is an ongoing process to be certain the hardware in a machine
	  is properly shutdown, so do not be surprised if this code does not
	  initially work for you.  It may help to enable device hotplugging
	  support.

endmenu

if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX )

menu "CPU Frequency scaling"

source "drivers/cpufreq/Kconfig"

config CPU_FREQ_SA1100
	bool
	depends on CPU_FREQ && (SA1100_H3100 || SA1100_H3600 || SA1100_H3800 || SA1100_LART || SA1100_PLEB || SA1100_BADGE4 || SA1100_HACKKIT)
	default y

config CPU_FREQ_SA1110
	bool
	depends on CPU_FREQ && (SA1100_ASSABET || SA1100_CERF || SA1100_PT_SYSTEM3)
	default y

config CPU_FREQ_INTEGRATOR
	tristate "CPUfreq driver for ARM Integrator CPUs"
	depends on ARCH_INTEGRATOR && CPU_FREQ
	default y
	help
	  This enables the CPUfreq driver for ARM Integrator CPUs.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say Y.

config CPU_FREQ_IMX
	tristate "CPUfreq driver for i.MX CPUs"
	depends on ARCH_IMX && CPU_FREQ
	default n
	help
	  This enables the CPUfreq driver for i.MX CPUs.

	  If in doubt, say N.

endmenu

endif

menu "Floating point emulation"

comment "At least one emulation must be selected"

config FPE_NWFPE
	bool "NWFPE math emulation"
	depends on !AEABI || OABI_COMPAT
	---help---
	  Say Y to include the NWFPE floating point emulator in the kernel.
	  This is necessary to run most binaries. Linux does not currently
	  support floating point hardware so you need to say Y here even if
	  your machine has an FPA or floating point co-processor podule.

	  You may say N here if you are going to load the Acorn FPEmulator
	  early in the bootup.

config FPE_NWFPE_XP
	bool "Support extended precision"
	depends on FPE_NWFPE
	help
	  Say Y to include 80-bit support in the kernel floating-point
	  emulator.  Otherwise, only 32 and 64-bit support is compiled in.
	  Note that gcc does not generate 80-bit operations by default,
	  so in most cases this option only enlarges the size of the
	  floating point emulator without any good reason.

	  You almost surely want to say N here.

config FPE_FASTFPE
	bool "FastFPE math emulation (EXPERIMENTAL)"
	depends on (!AEABI || OABI_COMPAT) && !CPU_32v3 && EXPERIMENTAL
	---help---
	  Say Y here to include the FAST floating point emulator in the kernel.
	  This is an experimental much faster emulator which now also has full
	  precision for the mantissa.  It does not support any exceptions.
	  It is very simple, and approximately 3-6 times faster than NWFPE.

	  It should be sufficient for most programs.  It may be not suitable
	  for scientific calculations, but you have to check this for yourself.
	  If you do not feel you need a faster FP emulation you should better
	  choose NWFPE.

config VFP
	bool "VFP-format floating point maths"
	depends on CPU_V6 || CPU_ARM926T
	help
	  Say Y to include VFP support code in the kernel. This is needed
	  if your hardware includes a VFP unit.

	  Please see <file:Documentation/arm/VFP/release-notes.txt> for
	  release notes and additional status information.

	  Say N if your target does not have VFP hardware.

config VFP_FASTVFP
        bool "FastVFP"
	depends on VFP
        help
          Say Y here to include the FAST Vector Floating Point in the kernel.
	  This means the VFP co-processor runs in a determinable time without 
	  support code assistance, regardless of the characteristics of the input data. 
	  In RunFast mode, no user exception traps are available.

	  It should be sufficient for most programs. It may be not suitable
	  for scientific calculations, but you have to check this for yourself.

endmenu

menu "Userspace binary formats"

source "fs/Kconfig.binfmt"

config ARTHUR
	tristate "RISC OS personality"
	depends on !AEABI
	help
	  Say Y here to include the kernel code necessary if you want to run
	  Acorn RISC OS/Arthur binaries under Linux. This code is still very
	  experimental; if this sounds frightening, say N and sleep in peace.
	  You can also say M here to compile this support as a module (which
	  will be called arthur).

endmenu

menu "Power management options"

source "kernel/power/Kconfig"

endmenu

source "net/Kconfig"

menu "Device Drivers"

source "drivers/base/Kconfig"

source "drivers/connector/Kconfig"

if ALIGNMENT_TRAP || !CPU_CP15_MMU
source "drivers/mtd/Kconfig"
endif

source "drivers/parport/Kconfig"

source "drivers/pnp/Kconfig"

source "drivers/block/Kconfig"

source "drivers/acorn/block/Kconfig"

if PCMCIA || ARCH_CLPS7500 || ARCH_IOP32X || ARCH_IOP33X || ARCH_IXP4XX \
	|| ARCH_L7200 || ARCH_LH7A40X || ARCH_PXA || ARCH_RPC \
	|| ARCH_S3C2410 || ARCH_SA1100 || ARCH_SHARK || FOOTBRIDGE \
	|| ARCH_IXP23XX
source "drivers/ide/Kconfig"
endif

source "drivers/scsi/Kconfig"

source "drivers/ata/Kconfig"

source "drivers/md/Kconfig"

source "drivers/message/fusion/Kconfig"

source "drivers/ieee1394/Kconfig"

source "drivers/message/i2o/Kconfig"

source "drivers/net/Kconfig"

source "drivers/isdn/Kconfig"

source "drivers/telephony/Kconfig"

# input before char - char/joystick depends on it. As does USB.

source "drivers/input/Kconfig"

source "drivers/char/Kconfig"

source "drivers/i2c/Kconfig"

source "drivers/spi/Kconfig"

source "drivers/w1/Kconfig"

source "drivers/hwmon/Kconfig"

#source "drivers/l3/Kconfig"

source "drivers/misc/Kconfig"

source "drivers/mfd/Kconfig"

source "drivers/leds/Kconfig"

source "drivers/media/Kconfig"

source "drivers/video/Kconfig"

source "sound/Kconfig"

source "drivers/hid/Kconfig"

source "drivers/usb/Kconfig"

source "drivers/mmc/Kconfig"

source "drivers/rtc/Kconfig"

endmenu

source "fs/Kconfig"

source "arch/arm/oprofile/Kconfig"

source "arch/arm/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"
